;;; 6.945 Problem Set 8
;;; Richard Futrell
;;; futrell@mit.edu

;;; Problem 1
;;;
;;; The time and space complexity is O(N^2) in the number of terminal
;;; nodes of the tree. This is because each call to append makes a
;;; copy of the fringe and walks down part of it, and append is called
;;; at least once for each node. 

;;; Problem 2
;;;
;;; A. Suppose the first element of stream2 takes infinitely long to
;;; compute. In that case if it is not thunkified before being passed
;;; to stream-append-deferred, then that first element will be
;;; evaluated by cons and we will be in trouble. 
;;;
;;; B. We delay the walk and build up an even stream as ans.

(define (lazy-fringe subtree)
  (define (walk subtree ans-thunk)
    (cond ((pair? subtree)
	   (walk (car subtree)
		 (lambda () (walk (cdr subtree) ans-thunk))))
	  ((null? subtree) (ans-thunk))
	  (else (cons-stream subtree (ans-thunk)))))
  (walk subtree (lambda () '())))

#| Tests

(lazy-same-fringe? '((a b) c ((d)) e (f ((g h))))
                   '(a b c ((d) () e) (f (g (h)))))
;Value: #t

(lazy-same-fringe?
 '((a b) c ((d)) e (f ((g h))))
 '(a b c ((d) () e) (g (f (h)))))

;Value: #f

|#

;;; Problem 3
;;;
;;; TODO

;;; Problem 4
;;;
;;; The bug seems to appear only when there are two iterators. But
;;; really it exists when there is just one. Observe:

(next-value foo)
;Value: a

(define cat (next-value foo))
;Value: cat

cat
;Value: b

(define dog (next-value foo))
;Value 2: (*done*) ; hey wait a minute...

dog
;Unbound variable: dog

;;; The fact that dog is unbound suggests that the define was never
;;; executed successfully; when we saw value (*done*), that was passed
;;; through a continuation to the REPL, short-circuiting the
;;; define. But what exactly is that continuation and where does it
;;; come from? Let's figure it out by calling next-value from
;;; somewhere other than the REPL.

(define (call-then-print thunk name)
  (let ((result (thunk)))
    (pp name)
    result))

(call-then-print (lambda () (next-value foo)) 'one)
one
;Value: a

(call-then-print (lambda () (next-value foo)) 'two)
two
;Value: b

(call-then-print (lambda () (next-value foo)) 'three)
one
;Value 2: (*done*)

(call-then-print (lambda () (next-value foo)) 'four)
one
;Value 2: (*done*)

;;; So *done* is being sent to the continuation that was current the
;;; first time we called next. This explains why we get ((*done*) a)
;;; in the example in the handout: The *done* is sent via the
;;; continuation to the point where we first called next-value; after
;;; jumping to that point, we proceed to get the first elements from
;;; the rest of the iterators in the let expression.

;;; So why is *done* sent to the initial continuation? First let's see
;;; what the coroutines really look like.

;;; make-coroutine reduces to this with initial values todo-future=#f,
;;; resume-point=supplicant:

(lambda (todo)
  (lambda (supplicant) ;supplicant=(lambda (value) ...)
    (if todo-future ;is there a saved future?
	(todo-future supplicant)
	(todo (lambda (value) 
		(set! resume-point ;gets (resume-point value)
		      (call/cc
		       (lambda (k)
			 (set! todo-future k)
			 (resume-point value)))))))))

;;; plugging in the buggy list-iterator as todo, we get:

(lambda (supplicant) 
  (if todo-future 
      (todo-future supplicant) ; THEN CLAUSE: todo-future is a
			       ; continuation that sends supplicant
			       ; off to be set as the resume-point in
			       ; the else-clause.
      (begin ; ELSE CLAUSE: We go here directly the first time
	     ; next-value is called; afterwards, we jump into this
	     ; clause from the then-clause.
	(for-each (lambda (value) 
		    (set! resume-point ;gets (resume-point value)
			  (call/cc
			   (lambda (k)
			     (set! todo-future k)
			     (resume-point value)))))
		  list)
	*done*) 
      ))

;;; The bug happens because when we use the continuation in the
;;; then-clause to jump into the else-clause, we are jumping into a
;;; state where the underlying continuation of the function is the
;;; one from when that else clause was first evaluated, i.e the first
;;; time next-value was called. So when we return *done* from the
;;; function we are returning it into that continuation, rather than
;;; the continuation from the most recent time we called
;;; next-value. 

;;; Problem 5

(define (make-pipe)
  (queue:make))


(define (pipe-writer pipe)
  (define (write-pipe thing)
    (without-interrupts
     (lambda ()
       (queue:add-to-end! pipe thing))))
  write-pipe)

(define (pipe-reader pipe)
  (define (read-pipe)
    (without-interrupts
     (lambda ()
       (queue:get-first pipe))))
  read-pipe)

#| Tests

(with-time-sharing-conspiracy
 (lambda ()
   (piped-same-fringe?
    '((a b) c ((d)) e (f ((g h))))
    '(a b c ((d) () e) (f (g (h)))))
   ))

(with-time-sharing-conspiracy
 (lambda ()
   (piped-same-fringe?
    '((a b) c ((d)) e (f ((g h))))
    '(a b c ((d) () e) (g (f (h)))))
   ))

(with-time-sharing-conspiracy
 (lambda ()
   (piped-same-fringe?
    '((a b) c ((d)) e (f ((g h))))
    '(a b c ((d) () e) (g (f ))))
   ))

|#

;;; Problem 6
