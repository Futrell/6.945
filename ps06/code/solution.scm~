;;; 6.945 Problem Set 6
;;; Richard Futrell
;;; futrell@mit.edu

(define call/cc call-with-current-continuation)

;;; Problem 6.1
;;; A. Here is snark-hunt.

(define (snark-hunt tree)
  (call-with-current-continuation
   (lambda (return)
     (define (hunt-for-snarks subtree)
       (for-each (lambda (x)
		   (cond ((pair? x)
			  (hunt-for-snarks x))
			 ((eq? x 'snark)
			  (return #t))))
		   subtree))
     (hunt-for-snarks tree)
     (return #f))))

#| Tests

(snark-hunt '())
;Value: #f

(snark-hunt '(snark))
;Value: #t

(snark-hunt '(1 2 3 snark 4 5))
;Value: #t

(snark-hunt '(((a b c) d (e f)) g (((snark . "oops") h) (i . j))))
;Value: #t

(snark-hunt '(((a b c) d (e f)) g (((snack . "oops") h) (i . j))))
;The object (snack . "oops"), passed as an argument to for-each, is
;not a list.

|#

;;; B. To show that we are only returning once, let's modify the
;;; continuation to print out the value before returning. If the value
;;; is returned more than once, it will be printed more than once.

(define (snark-hunt/instrumented tree)
  (call-with-current-continuation
   (lambda (return)
     (define (print-and-return x)
       (display x)
       (newline)
       (return x))
     (define (hunt-for-snarks subtree)
       (for-each (lambda (x)
                   (cond ((pair? x)
                          (hunt-for-snarks x))
                         ((eq? x 'snark)
			  (print-and-return #t))))
                   subtree))
     (hunt-for-snarks tree)
     (print-and-return #f))))


#| Tests

(snark-hunt/instrumented '())
#f
;Value: #f

(snark-hunt/instrumented '(snark))
#t
;Value: #t

(snark-hunt/instrumented '(1 2 3 snark 4 5 6))
#t
;Value: #t

(snark-hunt/instrumented '(((a b c) d (e f)) g (((snark . "oops") h) (i . j))))
#t
;Value: #t

(snark-hunt/instrumented '(((a b c) d (e f)) g (((snack . "oops") h) (i . j))))
;The object (snack . "oops"), passed as an argument to for-each, is
;not a list.

|# 

;;; That works but here is a more modular way to do it, using the
;;; coroutine manager shown in class.  I'd like to have this coroutine
;;; manager hanging around in my namespace because I do most of my
;;; programming in Python where I've gotten used to using these things
;;; all the time.


(define *done* (list '*done))
(define (done? x) (eq? x *done*))

(define (make-coroutine todo)
  (let ((continue #f))
    (lambda (supplicant)
      (let ((resume-point supplicant))
        (define (yield value)
          (set! resume-point
                (call-with-current-continuation
                 (lambda (k)
                   (set! continue k)
                   (resume-point value)))))
        (if continue
            (continue supplicant)
            (todo yield))))))

(define next call-with-current-continuation)

(define (walk-tree tree)
  (make-coroutine
   (lambda (yield)
     (define (walk tree)
       (for-each (lambda (x)
		   (if (pair? x)
		       (walk x)
		       (yield x)))
	       tree))
     (walk tree)
     (yield *done*))))

(define (iterator->list iterator)
  (let ((next-item (next iterator)))
    (if (eq? next-item *done*)
	'()
	(cons next-item 
	      (iterator->list iterator)))))

(define (snark-hunt tree)
  (let ((tree-walker (walk-tree tree)))
    (call-with-current-continuation
     (lambda (return)
       (define (iterate)
	 (let ((next-value (next tree-walker)))
	   (cond ((eq? next-value 'snark)
		  (return #t))
		 ((done? next-value)
		  (return #f))
		 (else (iterate)))))
       (iterate)
       (return #f)))))
			   
#| Tests

(snark-hunt '(1 2 (3 4) 5))
;Value: #f

(snark-hunt '(((a b c) d (e f)) g (((snark . "oops") h) (i . j))))
;Value: #t

|#

;;; Problem 6.2
;;; In the depth-first search, when a requirement fails, we try to
;;; find a value of k before trying new is and js; this means that we
;;; only explore scenarios where i = 10, 11, 12. In a breadth-first
;;; search, we update i, j, or k after a failure, and we cycle through
;;; many values of i before reaching one where j=16 and k=20. The
;;; extra calls to fail are coming from the non-pythagorean triples
;;; that get passed to require.
;;;
;;; The depth-first search strategy doesn't work for
;;; a-pythagorean-triple-from because it tries infinitely many values
;;; of i before trying new values of j and k. 

;;; Problem 6.3
;;; 
;;; A. If you are generating test cases and you won't be able to test
;;; them all, it would be better for them to be in random order so
;;; that a large range of possibilities is tested; the alternatives
;;; generated by a strict depth-first or breadth-first schedule would
;;; all be related. Also if you are doing Monte Carlo estimation you
;;; want your samples to be as uncorrelated as possible, so an
;;; unordered amb would be better.
;;;
;;; For fun, I'm going to generate random sentences using the code
;;; provided, using Alyssa P. Hacker's suggestion from SICP exercise
;;; 4.49.

(define (amb-choice lst)
  (if (null? lst)
      (amb)
      (amb (car lst) (amb-choice (cdr lst)))))

(define (parse-word word-list)
  (list (car word-list)
	(amb-choice (cdr word-list))))

(define (terminals tree)
  (cond ((pair? tree)
	 (if (or (pair? (car tree)) (null? (cdr tree)))
	     (append (terminals (car tree))
		     (terminals (cdr tree)))
	     (terminals (cdr tree))))
        ((null? tree) '())
        (else (list tree)))) ; it's a symbol

(define (generate-sentence) 
  (terminals (parse-sentence)))

#| 
(init-amb)
(generate-sentence)
;Value: (the student studies)

|#

;;; B. First redefine amb-list to order the alternatives. The order
;;; procedure will be modified fluidly. 

(define (amb-list alternatives)
  (if (null? alternatives)
      (set! *number-of-calls-to-fail*
            (+ *number-of-calls-to-fail* 1)))
  (call-with-current-continuation
   (lambda (k)
     (add-to-search-schedule
      (map (lambda (alternative)
             (lambda ()
               (within-continuation k alternative)))
           (order alternatives)))
     (yield))))

;;; Provide a default order:

(define (order alternatives) alternatives)

;;; Left order, right order, and random:

(define (left-to-right-order things)
  things)

(define (right-to-left-order things)
  (reverse things))

(define (list-remove-ref lst n)
  (define (remove-list-ref i n list-so-far)
    (cond ((null? list-so-far)
	   (error "List index out of range."))
	  ((equal? i n)
	   (cdr list-so-far))
	  (else 
	   (cons (car list-so-far)
		 (remove-list-ref (+ i 1)
				  n
				  (cdr list-so-far))))))
  (remove-list-ref 0 n lst))

(define (shuffle things)
  (let ((n (length things)))
    (if (< n 2)
	things
	(let* ((next-item-index (random n))
	       (next-item (list-ref things next-item-index))
	       (rest-of-list (list-remove-ref things next-item-index)))
	  (cons next-item (shuffle rest-of-list))))))

;;; A wrapper to do the fluid order assignment:

(define (with-alternative-order order-proc thunk)
  (call-with-current-continuation
   (lambda (k)
     (fluid-let ((order order-proc))
       (thunk)))))

(define (with-left-to-right-order thunk)
  (with-alternative-order left-to-right-order thunk))

(define (with-right-to-left-order thunk)
  (with-alternative-order right-to-left-order thunk))

(define (with-random-order thunk)
  (with-alternative-order shuffle thunk))

#| Tests

(init-amb)
(with-left-to-right-order generate-sentence)
;Value: (the student studies)

(init-amb)
(with-right-to-left-order generate-sentence)
; fills memory: there are too many sentences to enumerate them all!

(init-amb)
(with-random-order generate-sentence)
;Value: (the professor studies)

(init-amb)
(with-random-order generate-sentence)
;Value: (the student to the professor lectures)

|#

;;; Problem 6.4
;;;
;;; 

